use clap::{App, Arg};
use tokio::net::TcpStream;
use tokio::time::{timeout, Duration};
use tokio::sync::Semaphore;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let matches = App::new("Port Scanner")
        .version("1.0")
        .author("Your Name <you@example.com>")
        .about("Scans ports on a specified IP address")
        .arg(Arg::with_name("IP")
            .help("The IP address to scan")
            .required(true)
            .index(1))
        .get_matches();

    let ip = matches.value_of("IP").unwrap();
    let concurrency_limit = 100; // Number of concurrent port checks
    let semaphore = Arc::new(Semaphore::new(concurrency_limit));

    let mut open_ports: Vec<u16> = Vec::new();
    let mut tasks = Vec::new();

    for port in 1..65535 {
        let ip = ip.to_string();
        let permit = Arc::clone(&semaphore).acquire_owned().await.unwrap();
        tasks.push(tokio::spawn(async move {
            let is_open = probe_port(&ip, port).await;
            drop(permit);
            (port, is_open)
        }));
    }

    for task in tasks {
        let (port, is_open) = task.await.unwrap();
        if is_open {
            open_ports.push(port);
        }
    }

    if !open_ports.is_empty() {
        println!("Open Ports are:");
        for port in open_ports.iter() {
            println!("{}", port);
        }
    } else {
        println!("Looks like no ports are open :(");
    }
}

async fn probe_port(ip: &str, port: u16) -> bool {
    let addr = format!("{}:{}", ip, port);
    match timeout(Duration::from_millis(500), TcpStream::connect(&addr)).await {
        Ok(Ok(_stream)) => true,
        _ => false,
    }
}
