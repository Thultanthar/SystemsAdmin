use reqwest::Client;
use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;
use tokio::task;

async fn check_directory(client: Client, base_url: &str, dir: String) {
    let url = format!("{}/{}.html", base_url, dir);
    match client.get(&url).send().await {
        Ok(response) => {
            if response.status() != reqwest::StatusCode::NOT_FOUND {
                println!("Valid directory: {}", url);
            }
        }
        Err(_e) => {
            // Errors are silently ignored
        }
    }
}

async fn run(base_url: String, wordlist_path: String) {
    let client = Client::new();
    let path = Path::new(&wordlist_path);
    let file = File::open(path).expect("Failed to open wordlist file");
    let lines = io::BufReader::new(file).lines();

    let mut tasks = vec![];

    for line in lines {
        if let Ok(dir) = line {
            let client = client.clone();
            let base_url = base_url.clone();
            tasks.push(task::spawn(async move {
                check_directory(client, &base_url, dir).await;
            }));
        }
    }

    for task in tasks {
        let _ = task.await;
    }
}

#[tokio::main]
async fn main() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 3 {
        eprintln!("Usage: {} <base_url> <wordlist_path>", args[0]);
        std::process::exit(1);
    }
    let base_url = &args[1];
    let wordlist_path = &args[2];
    run(base_url.clone(), wordlist_path.clone()).await;
}
