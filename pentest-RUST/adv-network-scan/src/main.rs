use ipnetwork::IpNetwork;
use pnet::packet::icmp::{echo_request::MutableEchoRequestPacket, IcmpTypes, echo_reply::EchoReplyPacket};
use pnet::packet::Packet;
use pnet::transport::{transport_channel, TransportChannelType::Layer4, TransportProtocol, icmp_packet_iter};
use rand::seq::SliceRandom;
use rand::Rng;
use std::collections::HashMap;
use std::io::{self, Write};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::str::FromStr;
use std::sync::Arc;
use tokio::net::TcpStream;
use tokio::sync::Mutex;
use tokio::time::{self, Duration};

#[tokio::main]
async fn main() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: {} <CIDR>", args[0]);
        return;
    }

    let ports_to_scan = prompt_for_ports();
    let scan_ports_flag = ports_to_scan.is_some();
    let scan_speed = prompt_for_scan_speed();

    let cidr = &args[1];
    let network: IpNetwork = match IpNetwork::from_str(cidr) {
        Ok(n) => n,
        Err(e) => {
            eprintln!("Invalid CIDR: {}", e);
            return;
        }
    };

    let ips: Vec<Ipv4Addr> = match network {
        IpNetwork::V4(net) => net.iter().collect(),
        IpNetwork::V6(_) => {
            eprintln!("IPv6 is not supported");
            return;
        }
    };

    let mut rng = rand::thread_rng();
    let mut tasks = vec![];
    let results = Arc::new(Mutex::new(HashMap::new()));

    for ip in &ips {
        let ip = *ip;
        let results_clone = Arc::clone(&results);
        let delay = if scan_speed == "slow" {
            Duration::from_secs(rng.gen_range(1..5))
        } else {
            Duration::from_millis(0)
        };
        let ports_option = ports_to_scan.clone();
        let scan_speed_clone = scan_speed.clone();

        let task = tokio::spawn(async move {
            if ping_host(ip).await {
                let mut res = results_clone.lock().await;
                res.insert(ip, vec![]);
                if scan_ports_flag {
                    if let Some(ports) = ports_option {
                        let shuffled_ports: Vec<u16> = {
                            let mut ports = ports.clone();
                            let mut rng = rand::thread_rng();
                            ports.shuffle(&mut rng);
                            ports
                        };
                        scan_ports(ip, shuffled_ports, &mut res, scan_speed_clone).await;
                    }
                }
            }
        });
        tasks.push(task);

        // Random sleep between 1s to 5s to avoid rate limiting and detection
        time::sleep(delay).await;
    }

    for task in tasks {
        if let Err(e) = task.await {
            eprintln!("Task failed: {:?}", e);
        }
    }

    let results = results.lock().await;
    print_results(&results, scan_ports_flag);
}

fn prompt_for_ports() -> Option<Vec<u16>> {
    let mut input = String::new();
    println!("Enter the ports to scan (comma-separated), type 'all' to scan all ports from 1 to 65535, or type 'none' to skip port scanning:");

    io::stdout().flush().unwrap();
    io::stdin().read_line(&mut input).unwrap();

    let input = input.trim().to_lowercase();
    if input == "all" {
        Some((1..=65535).collect())
    } else if input == "none" {
        None
    } else {
        Some(
            input
                .split(',')
                .filter_map(|s| s.trim().parse().ok())
                .collect()
        )
    }
}

fn prompt_for_scan_speed() -> String {
    let mut input = String::new();
    println!("Enter scan speed ('fast' or 'slow'):");
    
    io::stdout().flush().unwrap();
    io::stdin().read_line(&mut input).unwrap();
    
    input.trim().to_lowercase()
}

async fn ping_host(ip: Ipv4Addr) -> bool {
    let (mut tx, mut rx) = match transport_channel(1024, Layer4(TransportProtocol::Ipv4(pnet::packet::ip::IpNextHeaderProtocols::Icmp))) {
        Ok((tx, rx)) => (tx, rx),
        Err(e) => {
            eprintln!("Failed to create transport channel: {}", e);
            return false;
        }
    };

    let mut rng = rand::thread_rng();
    let identifier = rng.gen::<u16>();
    let sequence_number = rng.gen::<u16>();

    let mut buffer = [0u8; 8];
    let mut packet = MutableEchoRequestPacket::new(&mut buffer).unwrap();
    packet.set_icmp_type(IcmpTypes::EchoRequest);
    packet.set_identifier(identifier);
    packet.set_sequence_number(sequence_number);
    let checksum = pnet::packet::util::checksum(packet.packet(), 1);
    packet.set_checksum(checksum);

    let timeout = Duration::from_secs(1);

    if let Err(e) = tx.send_to(packet, ip.into()) {
        eprintln!("Failed to send packet: {}", e);
        return false;
    }

    let mut iter = icmp_packet_iter(&mut rx);
    let start = std::time::Instant::now();

    while start.elapsed() < timeout {
        if let Ok(Some((packet, _))) = iter.next_with_timeout(timeout) {
            if let Some(reply) = EchoReplyPacket::new(packet.packet()) {
                if reply.get_identifier() == identifier && reply.get_sequence_number() == sequence_number {
                    return true;
                }
            }
        }
    }

    false
}

async fn scan_ports(ip: Ipv4Addr, ports: Vec<u16>, results: &mut HashMap<Ipv4Addr, Vec<u16>>, scan_speed: String) {
    for port in ports {
        let addr = SocketAddr::new(IpAddr::V4(ip), port);
        match tokio::time::timeout(Duration::from_secs(3), TcpStream::connect(addr)).await {
            Ok(Ok(_)) => {
                if let Some(ports) = results.get_mut(&ip) {
                    ports.push(port);
                }
            }
            Ok(Err(_)) | Err(_) => (),
        }

        // Random sleep between 100ms to 1s to avoid detection if slow scan is chosen
        let delay = if scan_speed == "slow" {
            Duration::from_millis(rand::thread_rng().gen_range(100..1000))
        } else {
            Duration::from_millis(0)
        };
        time::sleep(delay).await;
    }
}

fn print_results(results: &HashMap<Ipv4Addr, Vec<u16>>, scan_ports_flag: bool) {
    for (ip, ports) in results {
        println!("Host: {:?}", ip);
        if scan_ports_flag {
            if ports.is_empty() {
                println!("  No open ports found.");
            } else {
                println!("  Open ports:");
                for port in ports {
                    println!("    - {}", port);
                }
            }
        }
    }
}
